# docker-compose.prod.yml
# Production overrides for Multi-Tenant JLPT (mikan.uz)
#
# Usage:
#   docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
#
# This file OVERRIDES the base docker-compose.yml with production settings:
# - Removes all public port exposure (Nginx is the only external entry point)
# - Adds PgBouncer for connection pooling
# - Adds Nginx as reverse proxy (HTTP/HTTPS + WebSocket)
# - Adds resource limits (CPU, memory)
# - Configures graceful shutdown timeouts
# - Uses unless-stopped restart policy
#
# Architecture:
#   Internet -> Nginx (port 80/443)
#              |-- HTTP/REST -> web:8000 (Gunicorn)
#              +-- WebSocket -> daphne:8001 (Daphne)
#                     |
#                PgBouncer:6432 (connection pooling, internal only)
#                     |
#                PostgreSQL:5432 (internal only, no public access)
#                     |
#                Redis:6379 (internal only, no public access)

version: '3.8'

services:
  # ===========================================================================
  # DATABASE & CACHE (Internal, No Public Access)
  # ===========================================================================

  db:
    # Remove ports: makes it internal-only (no public access)
    ports: [] # Override: remove port 5432 from external exposure
    environment:
      POSTGRES_DB: ${DB_NAME:-jlpt_mock_db}
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?error} # REQUIRED: Fail if not set
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  redis:
    # Remove ports: makes it internal-only
    ports: [] # Override: remove port 6379 from external exposure
    command: redis-server --requirepass ${REDIS_PASSWORD:?error} --appendonly yes
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ===========================================================================
  # PGBOUNCER: Connection Pool (Internal, No Public Access)
  # ===========================================================================
  #
  # Configured 100% via environment variables. The edoburu/pgbouncer image
  # auto-generates pgbouncer.ini and userlist.txt at container startup.
  # No mounted .ini or userlist files -- avoids unresolved template variables.
  #
  # WHY PGBOUNCER:
  #   Without: 2300+ connections -> PostgreSQL max 200 -> "too many connections"
  #   With:    2300+ clients -> PgBouncer pools -> ~50 connections to PostgreSQL

  pgbouncer:
    image: edoburu/pgbouncer:latest
    container_name: jlpt_pgbouncer
    ports: [] # Internal only, no public access
    restart: unless-stopped
    environment:
      # Database connection (auto-generates [databases] and userlist.txt)
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${POSTGRES_PASSWORD:?error}
      DB_HOST: db
      DB_PORT: 5432
      DB_NAME: ${DB_NAME:-jlpt_mock_db}
      # Connection pooling settings
      POOL_MODE: transaction
      MAX_DB_CONNECTIONS: 50
      MAX_CLIENT_CONNECTIONS: 1000
      DEFAULT_POOL_SIZE: 25
      MIN_POOL_SIZE: 10
      RESERVE_POOL_SIZE: 5
      RESERVE_POOL_TIMEOUT: 3
      QUERY_WAIT_TIMEOUT: 120
      SERVER_IDLE_TIMEOUT: 600
      SERVER_LIFETIME: 3600
      SERVER_RESET_QUERY: RESET ALL
      AUTH_TYPE: md5
      # Logging
      VERBOSE: 1
      LOG_CONNECTIONS: 1
      LOG_DISCONNECTIONS: 1
      LOG_STATS: 1
      STATS_PERIOD: 60
      ADMIN_USERS: postgres
    depends_on:
      db:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.25'
          memory: 128M
    healthcheck:
      test:
        [
          'CMD',
          'pg_isready',
          '-h',
          'localhost',
          '-p',
          '6432',
          '-U',
          '${DB_USER:-postgres}',
        ]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ===========================================================================
  # NGINX: Reverse Proxy (The ONLY external entry point)
  # ===========================================================================

  nginx:
    image: nginx:1.25-alpine
    container_name: jlpt_nginx
    ports:
      - '80:80'
      - '443:443'
    restart: unless-stopped
    volumes:
      # Nginx configuration
      - ./deployment/nginx.production.conf:/etc/nginx/conf.d/default.conf:ro
      # Static & media files (served directly by Nginx, bypassing Gunicorn)
      - static_volume:/app/staticfiles:ro
      - media_volume:/app/media:ro
      # SSL certificates (Let's Encrypt)
      - /etc/letsencrypt:/etc/letsencrypt:ro
      # ACME challenge directory (Certbot renewal)
      - /var/www/html:/var/www/html:ro
      # Landing page (uncomment if serving a static landing site)
      # - /var/www/mikan-landing:/var/www/mikan-landing:ro
    depends_on:
      web:
        condition: service_healthy
      daphne:
        condition: service_started
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    healthcheck:
      test: ['CMD-SHELL', 'wget --quiet --tries=1 --spider http://127.0.0.1/health/ || exit 1']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    logging:
      driver: 'json-file'
      options:
        max-size: '50m'
        max-file: '5'

  # ===========================================================================
  # WEB APPLICATION SERVICES (Internal, No Public Access)
  # ===========================================================================

  web:
    ports: [] # Override: remove port 8000 from external exposure

    command: ['entrypoint.sh', 'web']

    # Production: NO source code volume mount (.:/app).
    # Only mount named volumes for persistent data.
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media

    restart: unless-stopped
    stop_grace_period: 60s

    environment:
      DJANGO_SETTINGS_MODULE: config.settings.production
      DB_HOST: pgbouncer
      DB_PORT: 6432
      DB_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?error}
      DB_NAME: ${DB_NAME:-jlpt_mock_db}
      # Redis: Cache on db/1, Celery on db/0 (separate namespaces)
      REDIS_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/1
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      REDIS_PASSWORD: ${REDIS_PASSWORD:?error}
      ALLOWED_HOSTS: ${ALLOWED_HOSTS:?error}
      DEBUG: 'false'

    depends_on:
      pgbouncer:
        condition: service_healthy
      redis:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G

    env_file: .env

    logging:
      driver: 'json-file'
      options:
        max-size: '50m'
        max-file: '5'

  daphne:
    ports: [] # Override: remove port 8001 from external exposure

    command: ['entrypoint.sh', 'daphne']

    # Production: NO source code volume mount.
    volumes: []

    restart: unless-stopped
    stop_grace_period: 30s

    environment:
      DJANGO_SETTINGS_MODULE: config.settings.production
      DB_HOST: pgbouncer
      DB_PORT: 6432
      DB_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?error}
      DB_NAME: ${DB_NAME:-jlpt_mock_db}
      # Redis: Cache on db/1, Channel layer + Celery on db/0
      REDIS_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/1
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      REDIS_PASSWORD: ${REDIS_PASSWORD:?error}
      DEBUG: 'false'

    depends_on:
      pgbouncer:
        condition: service_healthy
      redis:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

    env_file: .env

    logging:
      driver: 'json-file'
      options:
        max-size: '50m'
        max-file: '5'

  # ===========================================================================
  # CELERY SERVICES (Internal, No Public Access)
  # ===========================================================================

  celery_worker:
    ports: []

    command: ['entrypoint.sh', 'celery']

    # Production: NO source code volume mount. Only named volumes for media.
    volumes:
      - media_volume:/app/media

    restart: unless-stopped
    stop_grace_period: 45s

    environment:
      DJANGO_SETTINGS_MODULE: config.settings.production
      DB_HOST: pgbouncer
      DB_PORT: 6432
      DB_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?error}
      DB_NAME: ${DB_NAME:-jlpt_mock_db}
      # Redis: Cache on db/1, Celery on db/0
      REDIS_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/1
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      REDIS_PASSWORD: ${REDIS_PASSWORD:?error}
      DEBUG: 'false'

    depends_on:
      pgbouncer:
        condition: service_healthy
      redis:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 512M

    env_file: .env

    logging:
      driver: 'json-file'
      options:
        max-size: '50m'
        max-file: '5'

  celery_beat:
    ports: []

    command: ['entrypoint.sh', 'beat']

    # Production: NO source code volume mount.
    volumes: []

    restart: unless-stopped
    stop_grace_period: 10s

    environment:
      DJANGO_SETTINGS_MODULE: config.settings.production
      DB_HOST: pgbouncer
      DB_PORT: 6432
      DB_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?error}
      DB_NAME: ${DB_NAME:-jlpt_mock_db}
      # Redis: Cache on db/1, Celery on db/0
      REDIS_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/1
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:?error}@redis:6379/0
      REDIS_PASSWORD: ${REDIS_PASSWORD:?error}
      DEBUG: 'false'

    depends_on:
      pgbouncer:
        condition: service_healthy
      redis:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M

    env_file: .env

    logging:
      driver: 'json-file'
      options:
        max-size: '20m'
        max-file: '3'

# ===========================================================================
# VOLUMES (shared storage)
# ===========================================================================

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  static_volume:
    driver: local
  media_volume:
    driver: local
