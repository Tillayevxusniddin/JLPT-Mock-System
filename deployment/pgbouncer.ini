[databases]
# PgBouncer database configuration for Multi-Tenant JLPT
#
# NOTE: In production, this file is NOT mounted into the container.
# PgBouncer is configured 100% via environment variables in docker-compose.prod.yml.
# The edoburu/pgbouncer image auto-generates [databases] and userlist.txt at startup.
#
# This section is kept as a REFERENCE for manual/bare-metal deployments only.
# If mounting this file, replace the placeholder with the actual password.

jlpt_mock_db = "host=db port=5432 user=postgres dbname=jlpt_mock_db"

[pgbouncer]
# ============================================================================
# POOLING AND CONNECTIONS
# ============================================================================

# Pool mode: How connections are reused
#   session   : One connection per client session (default, safest, least pooling)
#   transaction: Reuse after each transaction (recommended for Django)
#   statement : Reuse after each statement (max pooling, may break some apps)
#
# For Django: Use 'transaction' mode (good balance of isolation and performance)
pool_mode = transaction

# Maximum number of connections to the backend database
# Critical for multi-tenant:
#   This is the PRIMARY limit. Set this to what PostgreSQL can handle.
#   Default PostgreSQL max_connections = 200
#   Recommended for this app: 50 (allows 50 concurrent DB operations)
#
# Calculate as: (web_workers + daphne + celery_tasks) / expected_concurrency
#   If: 50 web workers + 2000 daphne + 100 celery
#       But only ~10% active at once = (50+2000+100) / 10 = ~215 connections
#   So: max_db_connections = 50-100 (let PgBouncer queue excess)
max_db_connections = 50

# Maximum number of client connections PgBouncer will accept
# This is the UPSTREAM limit. Set high (clients queue at PgBouncer level)
#
# For 5000+ concurrent WebSocket users:
#   max_client_connections = 5000+ (PgBouncer queues them, pool provides connections)
max_client_connections = 1000

# Default pool size for each database/user
# How many connections to keep open per database
#
# Formula: max_db_connections / num_databases
#   If max_db_connections=50 and 1 database: default_pool_size = 25
#   If max_db_connections=50 and 2 databases: default_pool_size = 12
default_pool_size = 25

# Minimum number of connections to keep open (even if idle)
# Avoids startup latency when traffic spikes
min_pool_size = 10

# Extra connections reserved for super users or priority queries
reserve_pool_size = 5

# How long to wait before giving a connection to reserved pool clients
reserve_pool_timeout = 3

# How long a client can hold a connection (in seconds)
# 0 = unlimited (recommended for Django, which manages its own timeouts)
idle_in_transaction_session_timeout = 0

# ============================================================================
# QUERY TIMEOUTS & LIMITS
# ============================================================================

# Maximum time a query can run (in seconds)
# Prevents stuck queries from blocking the pool
# 0 = unlimited (use app-level timeouts instead)
query_wait_timeout = 120

# Maximum time to wait for a connection slot
# If all connections busy and client hasn't checked out a connection in this time,
# the client is disconnected
query_timeout = 0

# Cancel queries older than N seconds (0 = disable)
# Prevents long-running queries from starving the pool
# For exams: set to 0 (don't cancel user queries)
cancel_if_opened = 0

# Idle client connection timeout (seconds)
# Disconnect clients that haven't sent anything for this long
# 0 = unlimited (keep open, good for WebSockets)
client_idle_timeout = 0

# Idle connection timeout
# Close pooled connections to PostgreSQL that haven't been used in N seconds
# This helps recycle connections and detect stale ones
# Recommend: 600 (10 minutes) for long-lived connections
# (idle_in_transaction_session_timeout already set above)

# ============================================================================
# STATEMENT POOLING (Advanced)
# ============================================================================

# When using statement pooling mode, reset session variables after each statement
# This prevents one client's changes from affecting another
# Format: "SET var = val; SET var2 = val2;"
pkt_buf = 4096

# Semicolon-separated list of SQL statements to execute at the end of each
# client session. Used to reset connection state.
# For Django: Usually not needed (Django manages this)
server_reset_query = "RESET ALL"

# Disable queries that change connection parameters
# Good for statement pooling, but may break some apps
# Recommend: false (allow apps to set parameters)
server_reset_query_always = false

# ============================================================================
# MAINTENANCE & MONITORING
# ============================================================================

# How often to run maintenance (seconds)
# Checks for idle connections to close, health checks, etc.
maintenance_db = "postgres"

# Maximum lifetime of a backend connection (seconds)
# Closes connection after N seconds regardless of activity
# Prevents connection leaks and server memory bloat
# Recommend: 3600 (1 hour) for production
max_client_conn_age = 3600

# Close backend connection when it has been idle for N seconds
# Helps recycle connections
server_lifetime = 3600

# Drop idle connections after N seconds (close idle backend conns)
# This helps reduce the number of open connections to PostgreSQL
server_idle_timeout = 600

# ============================================================================
# LOGGING & MONITORING
# ============================================================================

# Logging verbosity (0=none, 1=warning, 2=info, 3=debug)
log_connections = 1
log_disconnections = 1
log_pooler_errors = 1
log_stats = 1

# How often to log statistics (seconds, 0 = never)
stats_period = 60

# Log queries that take longer than N milliseconds
# 0 = never log based on duration
log_query_max_time = 0

# ============================================================================
# AUTHENTICATION
# ============================================================================

# Username/password authentication
# Credentials are loaded from userlist.txt file (see below)
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
# NOTE: userlist.txt requires runtime password injection.
# The entrypoint generates this file at startup via envsubst.
# Alternatively, use auth_query for fully dynamic auth:
# auth_query = SELECT usename, passwd FROM pg_shadow WHERE usename=$1

# ============================================================================
# SSL/TLS (Optional, for production)
# ============================================================================

# Enable SSL/TLS between client and PgBouncer
# Requires certificates in /etc/pgbouncer/
# For now: disabled (use TLS at Nginx level instead)
server_tls_sslmode = disable
client_tls_sslmode = disable

# ============================================================================
# UNIX SOCKET (Optional, for local connections)
# ============================================================================

# Unix socket path (faster than TCP for local connections)
# Uncomment to enable:
# unix_socket_dir = /var/run/pgbouncer
# unix_socket_mode = 0666

# ============================================================================
# ADMINISTRATIVE SETTINGS
# ============================================================================

# Port to listen on
listen_port = 6432

# Address to listen on (0.0.0.0 for all interfaces, but only expose internally)
listen_addr = 0.0.0.0

# max_db_connections: already set to 50 in [pgbouncer] Pooling section above

# Number of seconds the server will wait for a response from a backend server
# before timing out
server_connect_timeout = 15

# Number of seconds the server will wait for a response from a client
# before timing out
server_timeout = 600

# reserve_pool_size: already set to 5 in [pgbouncer] Pooling section above

# Whether or not to accept PAUSE and RESUME commands from clients
# Recommended: true (allows graceful maintenance)
admin_users = postgres

# Database for admin commands (SHOW STATS, etc.)
# Can be any valid database
admindb = postgres

# Verbose console logging (for Docker logs)
verbose = 1

# PID file location
# pidfile = /var/run/pgbouncer.pid

# ============================================================================
# NOTES FOR MULTI-TENANT SCHEMA ARCHITECTURE
# ============================================================================
#
# PgBouncer Connection Pool Design for Separate Schemas:
#
# Challenge:
# ─────────
# Our JLPT system uses separate PostgreSQL schemas:
#   - public schema: Core tables (User, Center, ContactRequest)
#   - tenant_1, tenant_2, tenant_3, ... : Per-tenant tables
#
# When Django makes queries:
#   SET search_path TO tenant_5;
#   SELECT * FROM assignments WHERE user_id = 123;
#   -- PgBouncer sees this as a different "logical database"
#
# Without pooling: 45 web workers × 5 containers = 225 connections to PostgreSQL
#                + 2000 WebSocket clients = 2000+ connections
#                + Celery tasks = 100+ connections
#                = 2300+ connections (vs PostgreSQL default max 200)
#                → FATAL: too many connections
#
# With PgBouncer:
#   All 2300+ client connections talk to PgBouncer on port 6432
#   PgBouncer maintains a pool of ~50 connections to PostgreSQL
#   Requests queue until a connection is available
#   Result: PostgreSQL sees only ~50 connections, not 2300
#
# Configuration Strategy:
# ───────────────────────
# 1. pool_mode = transaction
#    Reuse connections after each transaction (good for Django ORM)
#    Avoids issues with app-level state (temp tables, cursors)
#
# 2. max_db_connections = 50
#    PostgreSQL can handle ~50 concurrent connections safely
#    More than 50 would cause memory bloat and slow queries
#
# 3. default_pool_size = 25
#    Keep 25 connections open to PostgreSQL normally
#    Allows up to 25 concurrent database operations without queuing
#
# 4. max_client_connections = 1000
#    Accept up to 1000 incoming connections from apps
#    Excess clients queue until a pool connection is available
#    (typically <100ms wait in normal traffic)
#
# 5. server_idle_timeout = 600
#    Close idle connections after 10 minutes
#    Prevents connection leaks and stale connections
#
# Result:
# ───────
# - Predictable connection count to PostgreSQL (fixed pool size)
# - Scales horizontally without increasing DB connection pressure
# - Works seamlessly with search_path schema switching
# - Django migrations and multi-tenant operations work transparently
#
# Testing the Pool:
# ─────────────────
# Connect to PgBouncer admin:
#   psql -p 6432 -U postgres pgbouncer
#   SHOW STATS;      # Show pool statistics
#   SHOW POOLS;      # Show current pool status
#   SHOW CLIENTS;    # Show connected clients
#
# Monitor from Docker:
#   docker logs jlpt_pgbouncer
#   # Look for "client_login_ok" and "server_connect_ok" messages
